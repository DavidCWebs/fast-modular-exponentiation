<h1 id="fast-modular-exponentiation">Fast Modular Exponentiation</h1>
<p>Modular exponentiation is used in public key cryptography.</p>
<p>It involves computing <em>b</em> to the power <em>e</em> (mod <em>m</em>):</p>
<p><em>c</em> ← <em>b</em><sup>e</sup> (mod <em>m</em>)</p>
<p>You could brute-force this problem by multiplying <em>b</em> by itself <em>e</em> - 1 times, but it is important to have <strong>fast</strong> (efficient) algorithms for this process.</p>
<p>In cryptography, the numbers involved are usually very large. Without an efficient algorithm, the process would take too long.</p>
<p>This article is educational - it is a summary of what I have learned about the process of modular exponentiation, with a few code implementations of a possible algorithm rather than a presentation of the most efficient methods.</p>
<h2 id="naive-exponentiation">Naive Exponentiation</h2>
<p>THe most basic approach would be to multiply <em>b</em> by itself <em>e</em> - 1 times, and performing floor division on the result to obtain the result modulo <em>m</em> (which will be the remainder or residue of floor division of the result by the modulus). There are a few problems with this approach:</p>
<ol style="list-style-type: decimal">
<li>If <em>b</em> and <em>e</em> are large numbers, <em>b</em><sup>e</sup> will be enormous - which causes problems representing the resultant data as a native type in many languages/systems.</li>
<li>If <em>b</em> and <em>e</em> are large, a lot of multiplications are required</li>
</ol>
<h2 id="slightly-less-naive-approach">Slightly Less Naive Approach</h2>
<p>For multiplication (mod <em>m</em>) congruence is maintained. In other words:</p>
<p>if a ≡ x (mod m) then a ∙ k ≡ x (mod m)</p>
<p>It follows that if we're just concerned with congruences (i.e. the residue mod m), multiplying the congruences provides the same result as multiplying the factors and then taking the result modulo m:</p>
<p>If a ∙ b ≡ x (mod m), then a (mod m) ∙ a (mod m) ≡ x (mod m)</p>
<p>In terms of an exponentiation algorithm, multiplying the result modulo <em>m</em> at each step leads to much smaller numbers which spares computational resources.</p>
<h3 id="slightly-better-algorithm">Slightly Better Algorithm</h3>
<p>For <em>c</em> ← <em>b</em><sup>e</sup> (mod <em>m</em>)</p>
<p>Start with 1, multiply by <em>b</em>, take the result mod(<em>m</em>), repeat <em>e</em> times.</p>
<p>In other words: 1. Start with <em>c</em> ← 1 2. Repeat <em>e</em> times: <em>c</em> ← <em>c</em> ∙ <em>b</em> mod <em>m</em></p>
<h2 id="exponent-is-a-power-of-two">Exponent is a Power of Two</h2>
<p>If <em>c</em> ← <em>b</em><sup>e</sup> (mod <em>m</em>) and</p>
<p><em>e</em> = 2<sup>k</sup></p>
<p>We can compute <em>c</em> using the &quot;squares&quot; method - this allows for fast computation of large positive integer powers of a number.</p>
<p>From rules of indices:</p>
<p>(b<sup>e</sup>)<sup>f</sup> = b<sup>ef</sup></p>
<p>For example, this allows a⁸, can be represented as ((a²)²)².</p>
<p>If you calculate a⁸ naively:</p>
<p><code>a⁸ = a ∙ a ∙ a ∙ a ∙ a ∙ a ∙ a ∙ a</code></p>
<p>...7 multiplications are required (the exponent - 1).</p>
<p>Alternatively, computing <code>a⁸</code> as <code>((a²)²)²</code> requires three multiplications:</p>
<p>a ∙ a = s₁ s₁ ∙ s₁ = s₂, where s₂ is equivalent to (a²)² s₂ ∙ s₂ = s₃, where s₃ is equivalent to ((a²)²)²</p>
<p>In this way, <code>aⁿ</code> requires no more than 2 log₂(<em>e</em>) multiplications, where <em>e</em> is the exponent.</p>
<p>So long as our exponent is a power of 2, and we multiply congruences at each stage, we have an efficient algorithm that can be converted to code:</p>
<h3 id="example-code-exponent-is-a-power-of-2">Example Code: Exponent is a Power of 2</h3>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co">#!/usr/bin/env python3</span>

<span class="kw">def</span> exponent_power_of_2(a, e_power2, mod):
    <span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span> (<span class="dv">0</span>, e_power2):
        a <span class="op">=</span> (a <span class="op">*</span> a) <span class="op">%</span> mod
    <span class="cf">return</span> a</code></pre></div>
<h2 id="exponent-is-not-necessarily-a-power-of-two">Exponent is Not Necessarily a Power of Two</h2>
<p>The previous algorithm gets us on the right track, but it has a major limitation - it only works if the exponent is a power of two.</p>
<p>We can however take the principle and generalise it so that it works for any number.</p>
<p>The idea is to take any number represented as the summation of powers of two - which as luck would have it, is exactly the way that modern computers represent numbers - and to create a running total of the required squares.</p>
<p>Example:</p>
<p>a<sup>11</sup> = a<sup>8</sup> ∙ a<sup>2</sup> ∙ a<sup>1<sup></p>
<p>...Notice that 8, 2 and one are powers of 2 (3, 1 and 0 respectively).</p>
<p>We can get the answer by working through each power of two up to the maximum possible given the size of e, squaring the base at each stage and only adding the squares to the result if the given power of two is a factor in the exponent.</p>
<h3 id="algorithm">Algorithm</h3>
<p>Given a base <code>b</code>, an exponent <code>e</code> and modulo <code>m</code>, compute b<sup>e</sup> (mod m):</p>
<ol style="list-style-type: decimal">
<li>Create an integer (or long) variable called <code>result</code> and set this result equal to 1.</li>
<li>Check the least significant bit (2⁰) of the exponent e. If it is 1, set <code>result</code> equal to <code>base</code>.</li>
<li>Check each bit in the exponent by iteratively bitshifting and masking against 1 - this checks each position in order, starting from the second-least-significant bit (we have already considered the least most significant bit in stage 2.</li>
<li>Start a loop</li>
<li>At each iteration, set <code>base</code> equal to the value of the previous <code>base</code> squared, modulo <code>m</code></li>
<li>At each stage, if the LSB of <code>e</code> is set, set <code>result</code> equal to the product of the previous <code>result</code> and the current <code>base</code> (which is the previous base squared, as described in stage 3), all modulo <code>m</code></li>
<li>When the value of <code>e</code> is NULL, end the loop</li>
<li>The value of result is the product of all b to the power of two for all powers of two that constitute the exponent.</li>
</ol>
<p>In summary, set the result to be 1. Starting from the least significant bit of the exponent, iteratively check each bit - which denotes that the particular power of two is a component of the exponent. Square the base modulo m at each stage. If the exponent bit is set, multiply the base with the current result, modulo m. The final result is the base raised to the exponent mod m - the product of a set of base raised to exponents that constitute the original exponent broken into powers of two.</p>
<h3 id="example-c">Example: C</h3>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">
<span class="dt">int</span> fastExp(<span class="dt">int</span> b, <span class="dt">int</span> e, <span class="dt">int</span> m)
{
    <span class="dt">int</span> result = <span class="dv">1</span>;
    <span class="kw">if</span> (<span class="dv">1</span> &amp; e)
        result = b;
    <span class="kw">while</span> (<span class="dv">1</span>) {
        <span class="kw">if</span> (!e) <span class="kw">break</span>;
        e &gt;&gt;= <span class="dv">1</span>;
        b = (b * b) % m;
        <span class="kw">if</span> (e &amp; <span class="dv">1</span>)
            result = (result * b) % m;
    }
    <span class="kw">return</span> result;
}</code></pre></div>
<h2 id="references">References</h2>
<ul>
<li><a href="https://www.khanacademy.org/computing/computer-science/cryptography#modarithmetic">Modular Arithmetic, Khan Academy</a>, with practice quizzes</li>
<li><a href="https://www.youtube.com/watch?v=DtV4Fwvn0e8">Intro to modular exponentiation</a>, You Tube, Mark's Education Tutorials</li>
<li><a href="https://www.youtube.com/watch?v=tTuWmcikE0Q">Modular Exponentiation Made Easy</a>, Randall Heyman YouTube</li>
</ul>
